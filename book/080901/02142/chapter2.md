---
title: "第二章 线性表 - 《数据结构导论》笔记"
date: 2023-08-29T14:46:12+08:00
slug: book/080901/02142/chapter2
image:
categories:
    - 书籍
tags:
    - 数据结构导论
    - 计算机科学与技术
    - 笔记
draft: false
---

## 目录

- [第一章 概论](../chapter1)
- [**第二章 线性表**](../chapter2)
- [第三章 栈、队列和数组](../chapter3)
- [第四章 树和二叉树](../chapter4)
- [第五章 图](../chapter5)
- [第六章 查找](../chapter6)
- [第七章 排序](../chapter7)

## 概要
1. 线性表
	1. 概念
	2. 特征
	3. 基本运算的功能描述
		- 初始化
		- 求表长
		- 读取元素
		- 定位
		- 插入
		- 删除
2. 线性表的顺序存储结构——顺序表
	1. 概念
	2. 用类C语言的描述
	3. 运算实现的关键步骤和算法
		- 容量
		- 表长
		- 插入
		- 删除
		- 定位
	4. 应用
		- 实现简单算法
		- 算法实现的分析
3. 线性表的链式存储结构——单链表
	1. 特点和结构
	2. 基本概念
		- 头指针
		- 头结点
		- 首结点
		- 尾结点
		- 空链表
	3. 用类C语言的描述
	4. 运算实现的关键步骤和算法
		- 插入
		- 删除
		- 定位
	5. 综合应用
		- 设计算法解决应用问题
5. 顺序表和链表的优缺点、适用场景
6. 循环链表和双向循环链表
	1. 特点和结构
	2. 用类C语言的描述
	3. 基本运算
		- 插入
		- 删除

## 线性表
### 概念
线性表Linear List是一种线性结构，它是由n（n ≥ 0）个数据元素组成的有穷序列，其中：
1. 数据元素又称为**结点**。
2. 这里的n代表线性表的总结点个数，又称为**表长**。
3. 当表长为0时，也就是线性表没有任何结点，称为**空表**，用 `()` 或 `Ø` 表示。
4. 线性表通常表示成：`(A1, A2, A3, ..., An)`，其中：
	- A1称为**起始结点**。
	- An称为**终端结点**。
	- A1是A2的**直接前驱**，A3是A2的**直接后继**，其他结点同理。

### 特征
1. 线性表中结点之间具有一对一的关系。
2. 非空表的情况下：
	- 除了起始结点没有直接前驱（例：A1），其他的结点有且仅有一个直接前驱（例：A2、A3等）。
	- 除了终端结点没有直接后继（例：An），其他的结点有且仅有一个直接后继（例：A1、A2等）。

### 基本运算的功能描述

> 以下的no指的是序号，文中所有提到的“位置”都是指序号。
> 
> 避免用i命名是怕和数组的下标混在一起，数组的下标是从0开始，而序号是从1开始。


1. 初始化`Initiate(L)`：建立一个空表`L=()`，L不包含任何结点。
2. 求表长`Length(L)`：返回线性表L的长度，以下简称表L。
3. 读取元素`Get(L, no)`：返回表L的第no个结点，当no超出`Length(L) ≥ no ≥ 1`范围，返回一特殊值。
4. 定位`Locate(L, x)`：返回表L中第一个结点的值等于x值的序号，如果找不到则返回0。
5. 插入`Insert(L, x, no)` ：两个步骤。
	- 在表L的第no个结点之前插入一个新结点x，no的合法范围：`Length(L) + 1 ≥ no ≥ 1`。
	- 表长度加1。
6. 删除`Delete(L, no)`：两个步骤。
	- 删除表L的第no个结点，no的合法范围：`Length(L) ≥ no ≥ 1`。
	- 表长度减1。

## 顺序表
### 概念
- 顺序存储：将结点依次存放在计算机内存中一组连续的存储单元中，逻辑结构中相邻的结点它的存储位置也相邻。
- 顺序表：用顺序存储实现的线性表，一般使用数组来表示顺序表。

### 用类C语言来描述
假设线性表的数据元素的类型为DataType，顺序表的结构定义如下：
```c
const int Maxsize = 100; // 预先定义一个足够大的常数
typedef struct
{
	DataType data[Maxsize]; // 存放数据的数组
	int length; // 顺序表的实际长度
} SeqList; // 顺序表类型名为SeqList
SeqList L; // 定义L为一个顺序表
```

例子：
```c
const int Maxsize = 7; // 预先定义数组大小
typedef struct
{
	int num; // 学号
	char name[8]; // 姓名
	int age; // 年龄
} DataType; // 定义结点的类型
typedef struct
{
	DataType data[Maxsize]; // 存放数据的数组
	int length; // 线性表的实际长度
} SeqList; // 顺序表的类型
SeqList student; // student是顺序表的名称
```

### 运算
#### 插入
算法：
```c
void func(SeqList L, DataType x, int no)
{
	if (L.length >= Maxsize) exit("表已满");
	// 等同于：no <= 0 || no >= L.length + 2
	if (no < 1 || no > L.length + 1) exit("插入位置不正确");
	for (j = L.length; j >= no; j--) {
		L.data[j] = L.data[j - 1];
	}
	L.data[no - 1] = x;
	L.length++;
}
```

步骤：
1. 检查插入位置是否合法。
	1. 表容量，**表满了以后不能再插入**。
	2. 插入位置：
		- **不能插入序号no = 0及之前的位置**，no = 1的位置可以插入。
		- 要插入的位置，它前面的位置不能是空的，也就是**不能断开插入**。
			- 例：插入第5个位置，第4个位置是空的。
2. 为插入位置腾出空位，从最后一个结点开始从后往前循环，将结点往后移一个位置，直到插入位置结束。
3. 插入新的结点x，也就是序号no的位置，对应下标为：no-1。
4. 表长度加一。

分析：
- 算法复杂度：O(n)。
- 平均移动次数：$\frac{n}{2}$。

插入算法中，元素的移动次数不仅与顺序表的长度n有关，还和插入的no位置有关：
- 当插入位置是n+1时，移动次数为0。
- 当插入位置是n时，移动次数为1，这个称为首项（从存在的元素中选取，它也可以是尾项）。
- 当插入位置是n-1时，移动次数为2。
- 当插入位置是n-2时，移动次数为3。
- ...
- 当插入位置是1时，移动次数为n，这个称为末项。

根据移动次数变化的规律可以看出：
1. 移动次数的计算方式为：`n - no + 1`。
2. 可插入的位置有：`n + 1`个。
3. 这是个[等差数列](https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/)。
	- 使用[高斯求和](https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/#求和)公式可以得出总的移动次数为：$\frac{(n + 1) \times n}{2}$。
	- 因此平均移动次数：$\frac{总移动次数}{可插入位置}$也就是$\frac{\frac{(n + 1) \times n}{2}}{n + 1}$约为$\frac{n}{2}$。

> 如果我有理解错平均移动次数，请大佬随时斧正，<a href="mailto:jaycedeng@outlook.com" target="_blank" class="link">联系我</a>。

#### 删除
算法：
```c
void DeleteSeqList(SeqList L, int no)
{
	// 等同于：no <= 0 || no >= L.length + 1
	if (no < 1 || no > L.length)
		exit("非法位置");
	for (j = no, j < L.length; j++) {
		L.data[j-1] = L.data[j];
	}
	L.length--;
}
```

步骤：
1. 检查删除位置是否合法，不能是0及之前的位置，也不能是超出表长之后的位置。
2. 覆盖结点，从删除位置开始，后一个结点移动到前一个位置，直到最后一个结点结束，即表示删除。
3. 表长度减一。

分析：
- 算法复杂度：O(n)。
- 平均移动次数：$\frac{n-1}{2}$。

跟插入算法一样：
- 当删除位置是n时，移动次数为0。
- 当删除位置是n-1时，移动次数为1。
- 当删除位置是n-2时，移动次数为2。
- ...
- 当删除位置是1时，移动次数为n-1。

根据规律得出：
- 移动次数的计算方式：`n - no`。
- 可删除的位置有：`n`个。
- 同样是[等差数列](https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/)。
	- 使用[高斯求和](https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/#求和)公式得出总的移动次数：$\frac{(0 + n - 1) \times n}{2}$。
	- 平均移动次数：$\frac{总移动次数}{可删除的位置}$也就是$\frac{\frac{(0 + n - 1) \times n}{2}}{n}$约为$\frac{n-1}{2}$。

> 如果我有理解错平均移动次数，请大佬随时斧正，<a href="mailto:jaycedeng@outlook.com" target="_blank" class="link">联系我</a>。

#### 定位
算法：
```c
void findSeqList(SeqList L, DataType x)
{
	int i = 0;
	while ((i < L.length) && (L.data[i] != x)) {
		i++;
	}
	if (i < L.length) {
		return i + 1;
	}
	return 0;
}
```

步骤：
1. 初始化一个下标值：0。
2. 从头到尾逐个比对，数组中的结点是否与结点x相等：
	1. 不相等则继续循环。
	2. 相等则表示已经找到，停止循环。
3. 返回查找结果。

#### 表长
只需要返回L.length即可

## 链表
- 链式存储：各个结点在内存中的存储位置并不连续，可以存放在不同位置，指针表示数据元素之间的逻辑关系。
- 链表：用链式存储实现的线性表，结点之间可以重新链接，链表分为：
	- 单链表：一个链表结点由一个数据元素和一个指针构成。
	- 循环链表：
	- 双向循环链表：

## 参考