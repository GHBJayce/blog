---
title: "第二章 线性表 - 《数据结构导论》笔记"
date: 2023-08-29T14:46:12+08:00
slug: book/080901/02142/chapter2
categories:
    - 书籍
tags:
    - 数据结构导论
    - 计算机科学与技术
    - 笔记
draft: false
---

## 目录

- [第一章 概论](../chapter1)
- [**第二章 线性表**](../chapter2)
- [第三章 栈、队列和数组](../chapter3)
- [第四章 树和二叉树](../chapter4)
- [第五章 图](../chapter5)
- [第六章 查找](../chapter6)
- [第七章 排序](../chapter7)

## 概要
1. 线性表
	1. 概念
	2. 特征
	3. 基本运算的功能描述
		- 初始化
		- 求表长
		- 读取元素
		- 定位
		- 插入
		- 删除
2. 线性表的顺序存储结构——顺序表
	1. 概念
	2. 用类C语言的描述
	3. 运算实现的关键步骤和算法
		- 容量
		- 表长
		- 插入
		- 删除
		- 定位
	4. 应用
		- 实现简单算法
		- 算法实现的分析
3. 线性表的链式存储结构——单链表
	1. 特点和结构
	2. 基本概念
		- 头指针
		- 头结点
		- 首结点
		- 尾结点
		- 空链表
	3. 用类C语言的描述
	4. 运算实现的关键步骤和算法
		- 插入
		- 删除
		- 定位
	5. 综合应用
		- 设计算法解决应用问题
5. 顺序表和链表的优缺点、适用场景
6. 循环链表和双向循环链表
	1. 特点和结构
	2. 用类C语言的描述
	3. 基本运算
		- 插入
		- 删除

## 线性表
### 概念
线性表Linear List是一种线性结构，它是由n（n ≥ 0）个数据元素组成的有穷序列，其中：
1. 数据元素又称为**结点**。
2. 这里的n代表线性表的总结点个数，又称为**表长**。
3. 当表长为0时，也就是线性表没有任何结点，称为**空表**，用 `()` 或 `Ø` 表示。
4. 线性表通常表示成：`(A1, A2, A3, ..., An)`，其中：
	- A1称为**起始结点**。
	- An称为**终端结点**。
	- A1是A2的**直接前驱**，其他结点同理。
	- A3是A2的**直接后继**，其他结点同理。

### 特征
1. 线性表中结点之间具有一对一的关系。
2. 非空表的情况下：
	- 除了起始结点没有直接前驱（例：A1），其他的结点有且仅有一个直接前驱（例：A2、A3等）。
	- 除了终端结点没有直接后继（例：An），其他的结点有且仅有一个直接后继（例：A1、A2等）。

### 基本运算的功能描述
1. 初始化`Initiate(L)`：建立一个空表`L=()`，L不包含任何结点。
2. 求表长`Length(L)`：返回线性表L的长度，以下简称表L。
3. 读取元素`Get(L, n)`：返回表L的第n个结点，当n超出`Length(L) ≥ n ≥ 1`范围，返回一特殊值。
4. 定位`Locate(L, x)`：返回表L中第一个结点的值等于x的序号，如果找不到则返回0。
5. 插入`Insert(L, x, n)` ：两个步骤。
	- 在表L的第n个结点之前插入一个新结点x，n的合法范围：`Length(L) + 1 ≥ n ≥ 1`。
	- 表长度加1。
6. 删除`Delete(L, n)`：两个步骤。
	- 删除表L的第n个结点，n的合法范围：`Length(L) ≥ i ≥ 1`。
	- 表长度减1。

> 这里的n指的是no序号，避免用i是怕和数组的下标混在一起，数组的下标是从0开始，而序号是从1开始。

## 顺序表
### 概念
- 顺序存储：将结点依次存放在计算机内存中一组连续的存储单元中，逻辑结构中相邻的结点它的存储位置也相邻。
- 顺序表：用顺序存储实现的线性表，一般使用数组来表示顺序表。

### 用类C语言来描述
假设线性表的数据元素的类型为DataType，顺序表的结构定义如下：
```c
const int Maxsize = 100; // 预先定义一个足够大的常数
typedef struct
{
	DataType data[Maxsize]; // 存放数据的数组
	int length; // 顺序表的实际长度
} SeqList; // 顺序表类型名为SeqList
SeqList L; // 定义L为一个顺序表
```

### 运算
```c
void func(SeqList L, DataType x, int n)
{
	// 1. 检查插入位置是否合法
	if (L.length === Maxsize) exit("表已满");
	// 序号小于1或者序号超过表长都不行
	if (n < 1 || i > L.length + 1) exit("插入位置不正确");
	// 2. 从后往前依次将结点往后一个位置移动，直到到达插入序号的位置，执行完移动后停止
	for (j = L.length; j >= n; j--) {
		L.data[j] = L.data[j - 1];
	}
	// 3. 插入新的结点x
	L.data[n - 1] = x;
	// 4. 表长加一
	L.length++;
}
```